# HG changeset patch
# User igerasim
# Date 1453300950 -10800
# Node ID a3a382d63d5b124ba59487e5399266489e880a43
# Parent  fec53330160b1ab952c1f22b7ab0076d8b39a3e3
8145446: Perfect pipe placement
Reviewed-by: alanb, jeff, igerasim, ahgross

diff -r fec53330160b -r a3a382d63d5b openjdk/jdk/src/windows/classes/sun/nio/ch/PipeImpl.java
--- openjdk/jdk/src/windows/classes/sun/nio/ch/PipeImpl.java	Wed Jan 13 11:28:31 2016 -0800
+++ openjdk/jdk/src/windows/classes/sun/nio/ch/PipeImpl.java	Wed Jan 20 17:42:30 2016 +0300
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@ import java.nio.channels.spi.*;
 import java.security.AccessController;
 import java.security.PrivilegedExceptionAction;
 import java.security.PrivilegedActionException;
+import java.security.SecureRandom;
 import java.util.Random;
 
 
@@ -47,6 +48,11 @@ import java.util.Random;
 class PipeImpl
     extends Pipe
 {
+    // Number of bytes in the secret handshake.
+    private static final int NUM_SECRET_BYTES = 16;
+
+    // Random object for handshake values
+    private static final Random RANDOM_NUMBER_GENERATOR = new SecureRandom();
 
     // Source and sink channels
     private SourceChannel source;
@@ -55,17 +61,6 @@ class PipeImpl
     // Random object for handshake values
     private static final Random rnd;
 
-    static {
-        Util.load();
-        byte[] someBytes = new byte[8];
-        boolean resultOK = IOUtil.randomBytes(someBytes);
-        if (resultOK) {
-            rnd = new Random(ByteBuffer.wrap(someBytes).getLong());
-        } else {
-            rnd = new Random();
-        }
-    }
-
     private class Initializer
         implements PrivilegedExceptionAction<Void>
     {
@@ -82,6 +77,10 @@ class PipeImpl
             SocketChannel sc2 = null;
 
             try {
+                // Create secret with a backing array.
+                ByteBuffer secret = ByteBuffer.allocate(NUM_SECRET_BYTES);
+                ByteBuffer bb = ByteBuffer.allocate(NUM_SECRET_BYTES);
+
                 // loopback address
                 InetAddress lb = InetAddress.getByName("127.0.0.1");
                 assert(lb.isLoopbackAddress());
@@ -95,20 +94,23 @@ class PipeImpl
                 InetSocketAddress sa
                     = new InetSocketAddress(lb, ssc.socket().getLocalPort());
                 sc1 = SocketChannel.open(sa);
-
-                ByteBuffer bb = ByteBuffer.allocate(8);
-                long secret = rnd.nextLong();
-                bb.putLong(secret).flip();
-                sc1.write(bb);
+                RANDOM_NUMBER_GENERATOR.nextBytes(secret.array());
+                do {
+                    sc1.write(secret);
+                } while (secret.hasRemaining());
+                secret.rewind();
 
                 // Get a connection and verify it is legitimate
                 for (;;) {
                     sc2 = ssc.accept();
-                    bb.clear();
-                    sc2.read(bb);
+                    do {
+                        sc2.read(bb);
+                    } while (bb.hasRemaining());
                     bb.rewind();
-                    if (bb.getLong() == secret)
+
+                    if (bb.equals(secret))
                         break;
+
                     sc2.close();
                 }
 
