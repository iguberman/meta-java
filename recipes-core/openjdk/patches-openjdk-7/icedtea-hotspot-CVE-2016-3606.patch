# HG changeset patch
# User shshahma
# Date 1462982626 14400
# Node ID 0095e54dcaa1acfe1614feff9600734c26af7ae8
# Parent  fa600c26dd0d9d2d081cd2a7b6ee18ff1ca898aa
8155981: Bolster bytecode verification
Reviewed-by: acorn, jdn
Contributed-by: harold.seigel@oracle.com

diff -r fa600c26dd0d -r 0095e54dcaa1 openjdk/hotspot/src/share/vm/classfile/verifier.cpp
--- openjdk/hotspot/src/share/vm/classfile/verifier.cpp	Tue May 31 09:24:08 2016 -0700
+++ openjdk/hotspot/src/share/vm/classfile/verifier.cpp	Wed May 11 12:03:46 2016 -0400
@@ -2323,9 +2323,17 @@
       case Bytecodes::_ifnonnull:
         target = bcs.dest();
         if (visited_branches->contains(bci)) {
-          if (bci_stack->is_empty()) return true;
-          // Pop a bytecode starting offset and scan from there.
-          bcs.set_start(bci_stack->pop());
+          if (bci_stack->is_empty()) {
+            if (handler_stack->is_empty()) {
+              return true;
+            } else {
+              // Parse the catch handlers for try blocks containing athrow.
+              bcs.set_start(handler_stack->pop());
+            }
+          } else {
+            // Pop a bytecode starting offset and scan from there.
+            bcs.set_start(bci_stack->pop());
+          }
         } else {
           if (target > bci) { // forward branch
             if (target >= code_length) return false;
@@ -2348,9 +2356,17 @@
       case Bytecodes::_goto_w:
         target = (opcode == Bytecodes::_goto ? bcs.dest() : bcs.dest_w());
         if (visited_branches->contains(bci)) {
-          if (bci_stack->is_empty()) return true;
-          // Been here before, pop new starting offset from stack.
-          bcs.set_start(bci_stack->pop());
+          if (bci_stack->is_empty()) {
+            if (handler_stack->is_empty()) {
+              return true;
+            } else {
+              // Parse the catch handlers for try blocks containing athrow.
+              bcs.set_start(handler_stack->pop());
+            }
+          } else {
+            // Been here before, pop new starting offset from stack.
+            bcs.set_start(bci_stack->pop());
+          }
         } else {
           if (target >= code_length) return false;
           // Continue scanning from the target onward.
